

定义变量的格式；
	数据类型  变量名 =  初始化值；

选择结构：
	switch(x) //x可以是:byte short int char四种类型
	{
		//符合哪个就从哪个开始执行
		case 4:
			System.out.println("a");
			break;
		case 6:
			System.out.println("b");
			break;
		case 2:
			System.out.println("c");
			break;
		default://必须执行的
			System.out.println("feifa");
	}
	
判断结构：
	if(boolean)//接收boolean类型的值
	{}
	else if(boolean)
	{}
	else
	{}

三元运算符：
	if else 结构 简写格式： 变量 = (条件表达式)?表达式1：表达式2；
		
	三元运算符：
		好处：可以简化if else代码。
		弊端：因为是一个运算符，所以运算完必须要有一个结果。
		
		例：
		int a = 9,b;
		b = (a>1)?100:200;
	

+=  -=  *=  /=  %=相当于 a=a+b a=a-b a=a*b以此类推

循环：
	for(初始化表达式；循环条件表达式；循环后的操作表达式)
	{
		执行语句；
	}

	while(条件表达式)
	{
		循环体(执行语句);
	}

	while:先判断条件，只有条件满足才执行循环体。
	do while: 先执行循环体，在判断条件，条件满足，再继续执行循环体。
	简单一句话：do while：无论条件是否满足，循环体至少执行一次。
	
	无限循环的最简单表现形式。
	for(;;){}
	while(true){}

	break：跳出循环
	continue：只能作用于循环结构。继续循环。特点：结束本次循环，继续下一次循环
数组：
	元素类型[] 数组名 = new 元素类型[元素个数或数组长度];
	二维数组：元素类型[][] 数组名 = new 元素类型[一维数组个数或长度][一维数组中元素的个数或长度];

转义字符：通过\ 来转变后面字母或者符号的含义。
\n:换行。
\b:退格。相当于backspace。
\r:按下回车键。window系统，回车符是由两个字符来表示\r\n.
\t:制表符。相当于tab键。

运算符：
	！:取反
	逻辑运算符用于连接boolean类型的表达式。	

	true & true = true;
	true & false = false;
	false & true = false;
	false & false = false;
	& : 只要两边的boolean表达式结果，有一个为false。那么结果就是false。只有两边都为true，结果为true。

	true | true = true;
	true | false = true;
	false | true = true;
	false | false = false;
	| : 两边只要有一个为true，结果为true。只有两边都有false，结果为false。

	^ : 异或；就是和|有点不一样。当true ^ true = false;
	true ^ true = false;
	true ^ false = true;
	false ^ true = true;
	false ^ false = false;
	^ : 两边相同结果是false。两边不同结果是true。

	&和&&的特点：
	&:无论左边是true是false。右边都运算。
	&&:当左边为false时，右边不运算。

	|：两边都参与运算。
	||：当左边为true。右边不运算。


函数（方法）

	为了提高代码的复用性。对代码进行抽取。
	将这个部分定义成一个独立的功能。方便与日后使用。
	java中对功能的定义是通过函数的形式来体现的。

	需要定义功能，完成一个整数的*3+5的运算，

	1,先明确函数定义的格式。
	
	修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数2，)
	{
			执行语句;
			return 返回值;
	}
	
	当函数运算后，没有具体的返回值时，这是返回值类型用一个特殊的关键字来标识。
	该关键字就是void。void:代表的是函数没有具体返回值的情况。
	当函数的返回值类型是void时，函数中的return语句可以省略不写。

重载：
	当定义的功能相同，但参与运算的未知内容不同。
	那么，这时就定义一个函数名称以表示其功能，方便阅读，而通过参数列表的不同来区分多个同名函数。

对象：
	对象一建立就会调用与之对应的构造函数。

	构造函数的作用：可以用于给对象进行初始化。

	构造函数的小细节：
	当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。

	当在类中自定义了构造函数后，默认的构造函数就没有了。


	构造函数和一般函数在写法上有不同。

	在运行上也有不同。
	构造函数是在对象一建立就运行。给对象初始化。
	而一般方法是对象调用才执行，给是对象添加对象具备的功能。

	一个对象建立，构造函数只运行一次。
	而一般方法可以被该对象调用多次。

	什么时候定义构造函数呢？
	当分析事物时，该事物存在具备一些特性或者行为，那么将这些内容定义在构造函数中。

	一个类中默认会有一个空参数的构造函数，
	这个默认的构造函数的权限和所属类一致。
	如果类被public修饰，那么默认的构造函数也带public修饰符。
	如果类没有被public修饰，那么默认的构造函数，也没有public修饰。

	默认构造构造函数的权限是随着的类的变化而变化的

构造代码块：
	作用：给对象进行初始化。
	对象一建立就运行，而且优先于构造函数执行。
	和构造函数的区别：
	构造代码块是给所有对象进行统一初始化，
	而构造函数是给对应的对象初始化。

	构造代码快中定义的是不同对象共性的初始化内容。{}就是构造代码块

静态代码块。
	格式：
	static
	{
		静态代码块中的执行语句。
	}

	特点：随着类的加载而执行，只执行一次,并优先于主函数。
	用于给类进行初始化的。

private :
	私有，权限修饰符：用于修饰类中的成员(成员变量，成员函数)。
	私有只在本类中有效。

	将age私有化以后，类以外即使建立了对象也不能直接访问。
	但是人应该有年龄，就需要在Person类中提供对应访问age的方式。

	注意：私有仅仅是封装的一种表现形式。


	之所以对外提供访问方式，就因为可以在访问方式中加入逻辑判断等语句。
	对访问的数据进行操作。提高代码健壮性。
		

this：
	this:看上去，是用于区分局部变量和成员变量同名情况。
	this为什么可以解决这个问题？
	this到底代表的是什么呢？

	this：就代表本类的对象，到底代表哪一个呢？
		this代表它所在函数所属对象的引用。
		简单说：哪个对象在调用this所在的函数，this就代表哪个对象。


	this的应用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。
			但凡本类功能内部使用了了本类对象，都用this表示。
	this语句 :用于构造函数之间进行互相调用。
	this语句只能定义在构造函数的第一行。因为初始化要先执行。


成员变量和局部变量。
作用范围。
成员变量作用于整个类中。
局部变量变量作用于函数中，或者语句中。
在内存中的位置：
成员变量：在堆内存中，因为对象的存在，才在内存中存在。
局部变量：存在栈内存中。


静态的应用：
	静态：static。
	用法：是一个修饰符，用于修饰成员(成员变量，成员函数).
	当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，
	还可以直接被类名调用。类名.静态成员。


	static特点：
		1，随着类的加载而加载。
		   也就说：静态会随着类的消失而消失。说明它的生命周期最长。

		2，优先于的对象存在
		明确一点：静态是先存在。对象是后存在的。

		3，被所有对象所共享
		4，可以直接被类名所调用。

		实例变量和类变量的区别：
		1，存放位置。
			类变量随着类的加载而存在于方法区中。
			实例变量随着对象的建立而存在于堆内存中。
		2，生命周期：
			类变量生命周期最长，随着类的消失而消失。
			实例变量生命周期随着对象的消失而消失。



		静态使用注意事项：
		1，静态方法只能访问静态成员。
			非静态方法既可以访问静态也可以访问非静态。
		2，静态方法中不可以定义this，super关键字。
			因为静态优先于对象存在。所以静态方法中不可以出现this。
		3，主函数是静态的。
			


		静态有利有弊
		利处：对对象的共享数据进行单独空间的存储，节省空间。没有必要每一个对象中都存储一份。
			可以直接被类名调用。
		弊端：生命周期过长。
			  访问出现局限性。(静态虽好，只能访问静态。)
	什么时候使用静态：

		要从两方面下手：
		因为静态修饰的内容有成员变量和函数。
		什么时候定义静态变量(类变量)呢？
		当对象中出现共享数据时，该数据被静态所修饰。
		对象中的特有数据要定义成非静态存在于堆内存中。



		什么时候定义静态函数呢？

		当功能内部没有访问到肺静态数据(对象的特有数据)，
		那么该功能可以定义成静态的


	虽然可以通过建立ArrayTool的对象使用这些工具方法，对数组进行操作。
	发现了问题：
	1，对象是用于封装数据的，可是ArrayTool对象并未封装特有数据。
	2，操作数组的每一个方法都没有用到ArrayTool对象中的特有数据。

	这时就考虑，让程序更严谨，是不需要对象的。
	可以将ArrayTool中的方法都定义成static的。直接通过类名调用即可。

	将方法都静态后，可以方便于使用，但是该类还是可以被其他程序建立对象的。
	为了更为严谨，强制让该类不能建立对象。
	可以通过将构造函数私有化完成。