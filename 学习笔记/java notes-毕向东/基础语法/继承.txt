Java语言中：java只支持单继承，不支持多继承。

因为多继承容易带来安全隐患:当多个父类中定义了相同功能，
当功能内容不同时，子类对象不确定要运行哪一个。
但是java保留这种机制。并用另一种体现形式来完成表示。多实现。


java支持多层继承。也就是一个继承体系

如何使用一个继承体系中的功能呢？

想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中共性功能。
通过了解共性功能，就可以知道该体系的基本功能。
那么这个体系已经可以基本使用了。
那么在具体调用时，要创建最子类的对象，为什么呢？
一是因为有可能父类不能创建对象，
二是创建子类对象可以使用更多的功能，包括基本的也包括特有的。


简单一句话：查阅父类功能，创建子类对象使用功能。

继承：
	特点：
		1，提高了代码的复用性。
		2，让类与类之间产生关系，是多态性的前提。

	Java中的继承。
		1，java只支持单继承，不支持多继承。为啥呢？答案：因为继承了多个父类如果有相同方法时，
												子类对象不确定运行哪一个。
		2，Java还支持多层继承。A-->B--->C  原来可以形成继承体系。
			想要使用体系功能，"查阅父类功能，建立子类对象调用功能。"
			注解：父类的由来其实是由事物中的共性内容不断向上抽取而来的。
				所以父类中定义的是该体系中的最基本，最共性功能。
	
继承出现后，代码上也有一些特点：
	类中成员：
	1，变量。
	2，函数。
	3，构造函数。

	1,变量
		如果子类中出现非私有的同名成员变量时，
		子类要访问本类中的变量，用this
		子类要访问父类中的同名变量，用super。

		super的使用和this的使用几乎一致。
		this代表的是本类对象的引用。
		super代表的是父类对象的引用。

		（
		当子父类中定义了相同的名称的成员变量，
		子类要使用父类中的同名变量时，需要使用关键字super来区分。
		一般不会出现这种情况，因为父类中有了，子类不需要定义。
		而且父类定义时，一般变量都私有化。
		）

	2,子父类中的函数。

		当子类出现和父类一模一样的函数时，
		当子类对象调用该函数，会运行子类函数的内容。
		如同父类的函数被覆盖一样。

		这种情况是函数的另一个特性：重写(覆盖)


		当子类继承父类，沿袭了父类的功能，到子类中，
		但是子类虽具备该功能，但是功能的内容却和父类不一致，
		这时，没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。


		覆盖：
		1，子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。

		2，静态只能覆盖静态。

		记住大家：
		重载：只看同名函数的参数列表。
		重写：子父类方法要一模一样。

		（
		子类可以直接访问父类中非私有的成员函数。
		特殊情况：当子类中定义了与父类一模一样的方法时，会发生覆盖操作。大多指的是非静态方法。
		最终会运行子类的方法，父类相当于被覆盖了。
		函数的另一个特性：覆盖（重写，复写）。
		什么时候用啊？
		当父类的功能要被修改时，不建议修改源码。因为是灾难。
	        只要通过一个类继承原有类，定义一个新的升级后的功能即可。
		但是功能是相同的，只是实现方法改变。这是子类可以沿袭父类中的功能定义，
		并重写功能内容。这就是覆盖。

		覆盖很爽，但是有注意事项：
		1，子类覆盖父类时，必须权限要大于等于父类权限。
		2，静态不能覆盖非静态。
			）

	3，子父类中的构造函数。

		在对子类对象进行初始化时，父类的构造函数也会运行，
		那是因为子类的构造函数默认第一行有一条隐式的语句 super();
		super():会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super();

		为什么子类一定要访问父类中的构造函数。

		因为父类中的数据子类可以直接获取。所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的。
		所以子类在对象初始化时，要先访问一下父类中的构造函数。
		如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

		注意：super语句一定定义在子类构造函数的第一行。



		子类的实例化过程。

		结论：
		子类的所有的构造函数，默认都会访问父类中空参数的构造函数。
		因为子类每一个构造函数内的第一行都有一句隐式super();

		当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问父类中的构造函数。

		当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数。
		子类中至少会有一个构造函数会访问父类中的构造函数。

		（
		构造函数可以本类进行对象初始化，也可以给子类对象进行初始化。
		子类对象初始化过程：
		子类中的所有构造方法都会访问父类中空参数的构造函数，
		因为每一个构造函数的第一行，都有一句隐式的super语句。
		为什么要有这条语句？
		因为子类会获取到父类中的数据，必须要先明确父类对数据的初始化过程。

		当父类中没有空参数构造函数时，子类构造函数必须通过super句来明确要访问的父类中指定的构造函数。

		当时子类构造函数也可以通过this语句访问本类中的构造函数。
		但是子类中肯定，至少有一个构造函数会访问父类。）


final : 
	最终。作为一个修饰符，
	1，可以修饰类，函数，变量。
	2，被final修饰的类不可以被继承。为了避免被继承，被子类复写功能。
	3，被final修饰的方法不可以被复写。
	4，被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，有可以修饰局部变量。
		当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字。方便于阅读。
		而这个值不需要改变，所以加上final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成。
		单词间通过_连接。
	5，内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。
