#广播接收者
* 现实中：电台要发布消息，通过广播把消息广播出去，使用收音机，就可以收听广播，得知这条消息
* Android中：系统在运行过程中，会产生会多事件，那么某些事件产生时，比如：电量改变、收发短信、拨打电话、屏幕解锁、开机，系统会发送广播，只要应用程序接收到这条广播，就知道系统发生了相应的事件，从而执行相应的代码。使用广播接收者，就可以收听广播

###创建广播接收者
1. 定义java类继承BroadcastReceiver
2. 在清单文件中定义receiver节点，定义name属性，指定广播接收者java类的全类名
3. 在intent-filter的节点中，指定action子节点，action的值必须跟要接受的广播中的action匹配，比如，如果要接受打电话广播，那么action的值必须指定为

		<action android:name="android.intent.action.NEW_OUTGOING_CALL"/>

* 因为打电话广播中所包含的action，就是"android.intent.action.NEW_OUTGOING_CALL"，所以我们定义广播接收者时，
  action必须与其匹配，才能收到这条广播
* 即便广播接收者所在进程已经被关闭，当系统发出的广播中的action跟该广播接收者的action匹配时，系统会启动该广播接收者所在的进程，
  并把广播发给该广播接收者

###短信防火墙
* 系统发送短信广播时，是怎么把短信内容存入广播的，我们就只能怎么取出来
* 如果短信过长，那么发送时会拆分成多条短信发送，那么短信广播中就会包含多条短信
* 4.0之后，广播接收者所在进程如果从来没启动过，那么广播接收者不会生效
* 4.0之后，如果系统自动关闭广播接收者所在进程，在广播中的action跟该广播接收者的action匹配时，系统会启动该广播接收者所在的进程，但是如果是用户手动关闭该进程，
那么该进程会进入冻结状态，再也不会启动了，直到用户下一次手动启动该进程

###广播的分类
#####无序广播
* 所有与广播中的action匹配的广播接收者都可以收到这条广播，并且是没有先后顺序，视为同时收到
#####有序广播
* 所有与广播中的action匹配的广播接收者都可以收到这条广播，但是是有先后顺序的，按照广播接收者的优先级排序

---
#服务
* Service
* 运行于后台的一个组件，用来运行适合运行在后台的代码，服务是没有前台界面，可以视为没有界面的activity
###进程优先级
1. 前台进程：拥有一个正在与用户交互的Activity（onResume方法被调用）的进程
2. 可见进程：拥有一个可见但是没有焦点的Activity（onPause方法被调用）
3. 服务进程：拥有一个通过startService方法启动的服务
4. 后台进程：拥有一个不可见的Activity（onStop方法被调用）的进程
5. 空进程：没有拥有任何活动的应用组件的进程

###电话录音机
#####电话的状态
* 空闲状态
* 响铃状态
* 摘机状态

#####录音机
* 音频文件的编码和格式不是一一对应的